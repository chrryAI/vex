// Secure Express server for malware scanning
const express = require("express")
const NodeClam = require("clamscan")
const multer = require("multer")
const helmet = require("helmet")
const rateLimit = require("express-rate-limit")
const fileType = require("file-type")
const sanitize = require("sanitize-filename")
const crypto = require("crypto")

const app = express()

// Security: Enable helmet for security headers
app.use(helmet())

// Security: Trust proxy for rate limiting (if behind reverse proxy)
app.set("trust proxy", 1)

// Security: Rate limiting - prevent abuse
const scanLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // limit each IP to 10 requests per 15 minutes
  message: { error: "Too many scan requests from this IP, please try again later" },
  standardHeaders: true,
  legacyHeaders: false,
})

// Security: File size and memory limits
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 100 * 1024 * 1024, // 100MB max
    files: 1, // Only 1 file per request
  },
})

// Configuration from environment variables
const CONFIG = {
  CLAMAV_HOST: process.env.CLAMAV_HOST || "localhost",
  CLAMAV_PORT: parseInt(process.env.CLAMAV_PORT || "3310"),
  CLAMAV_TIMEOUT: parseInt(process.env.CLAMAV_TIMEOUT || "300000"),
  API_KEY_HASH: process.env.API_KEY_HASH, // SHA256 hash of API key
  PORT: parseInt(process.env.PORT || "3006"),
  NODE_ENV: process.env.NODE_ENV || "development",
  LOG_LEVEL: process.env.LOG_LEVEL || "info",
}

// Allowed MIME types - strict validation
const ALLOWED_MIME_TYPES = [
  "video/quicktime", // mov
  "video/mp4",
  "video/webm",
  "video/x-msvideo", // avi
  "video/x-matroska", // mkv
  "image/png",
  "image/jpeg",
  "image/gif",
  "application/pdf",
  "text/plain",
  "application/json",
  "application/zip",
  "application/x-zip-compressed",
]

let clamav = null

// Logging utility
function log(level, message, meta = {}) {
  const timestamp = new Date().toISOString()
  const logEntry = {
    timestamp,
    level,
    message,
    ...meta,
  }

  if (CONFIG.NODE_ENV === "production") {
    console.log(JSON.stringify(logEntry))
  } else {
    console.log(`[${timestamp}] [${level.toUpperCase()}] ${message}`, meta)
  }
}

// Initialize ClamAV
async function initClamAV() {
  if (clamav) return clamav

  try {
    clamav = await new NodeClam().init({
      clamdscan: {
        host: CONFIG.CLAMAV_HOST,
        port: CONFIG.CLAMAV_PORT,
        timeout: CONFIG.CLAMAV_TIMEOUT,
        multiscan: true,
        reloadDb: false,
        active: true,
        bypassTest: false,
      },
      preference: "clamdscan",
    })

    log("info", "ClamAV initialized successfully", {
      host: CONFIG.CLAMAV_HOST,
      port: CONFIG.CLAMAV_PORT,
    })
    return clamav
  } catch (error) {
    log("error", "ClamAV initialization failed", { error: error.message })
    throw error
  }
}

// Security: Hash API key for comparison
function hashApiKey(key) {
  // Use a key-derivation function (PBKDF2) instead of a fast hash to
  // make offline brute-force of the API key more expensive.
  //
  // NOTE: API_KEY_HASH must be generated with the same parameters:
  //   const crypto = require("crypto");
  //   const hash = crypto
  //     .pbkdf2Sync(apiKey, "malwareScanner-api-key", 100000, 32, "sha256")
  //     .toString("hex");
  const ITERATIONS = 100000
  const KEY_LENGTH = 32 // bytes
  const DIGEST = "sha256"
  const SALT = "malwareScanner-api-key" // constant, non-secret salt for this application
  return crypto.pbkdf2Sync(key, SALT, ITERATIONS, KEY_LENGTH, DIGEST).toString("hex")
}

// Security: Middleware to check API key
function checkApiKey(req, res, next) {
  // If no API key hash is configured, skip authentication (dev mode)
  if (!CONFIG.API_KEY_HASH) {
    if (CONFIG.NODE_ENV === "production") {
      log("error", "API_KEY_HASH not configured in production", {
        ip: req.ip,
      })
      return res.status(500).json({ error: "Server misconfiguration" })
    }
    return next()
  }

  const headerVal = req.headers["x-api-key"]
  const providedKey = Array.isArray(headerVal) ? headerVal[0] : headerVal

  if (!providedKey) {
    log("warn", "Missing API key", { ip: req.ip })
    return res.status(401).json({ error: "Unauthorized: Missing API key" })
  }

  // Compare hashed values using timing-safe comparison
  const providedHashHex = hashApiKey(providedKey)
  const expectedHashHex = CONFIG.API_KEY_HASH || ""
  const providedHash = Buffer.from(providedHashHex, "hex")
  const expectedHash = Buffer.from(expectedHashHex, "hex")

  if (providedHash.length !== expectedHash.length) {
    log("warn", "Invalid API key", { ip: req.ip })
    return res.status(401).json({ error: "Unauthorized: Invalid API key" })
  }

  try {
    if (!crypto.timingSafeEqual(providedHash, expectedHash)) {
      log("warn", "Invalid API key", { ip: req.ip })
      return res.status(401).json({ error: "Unauthorized: Invalid API key" })
    }
  } catch (e) {
    log("warn", "Invalid API key", { ip: req.ip })
    return res.status(401).json({ error: "Unauthorized: Invalid API key" })
  }

  next()
}

// Security: Validate MIME type using magic numbers
async function validateFileType(buffer, filename, fallbackMime) {
  try {
    const type = await fileType.fromBuffer(buffer)

    if (!type) {
      // Fallback: trust provided mimetype only for known-safe textual/media types
      if (fallbackMime && ALLOWED_MIME_TYPES.includes(fallbackMime)) {
        log("info", "Using fallback MIME type from request", {
          filename,
          mime: fallbackMime,
        })
        return { valid: true, mimeType: fallbackMime }
      }
      log("warn", "Could not detect file type and no safe fallback", { filename })
      return { valid: false, reason: "Unknown file type" }
    }

    if (!ALLOWED_MIME_TYPES.includes(type.mime)) {
      log("warn", "Disallowed file type", {
        filename,
        detected: type.mime
      })
      return {
        valid: false,
        reason: `File type ${type.mime} not allowed`
      }
    }

    return { valid: true, mimeType: type.mime }
  } catch (error) {
    log("error", "File type validation error", {
      filename,
      error: error.message
    })
    return { valid: false, reason: "File validation failed" }
  }
}

// Health check (no auth required)
app.get("/health", (req, res) => {
  const health = {
    status: "ok",
    service: "malware-scanner",
    version: "1.0.0",
    clamav: clamav ? "connected" : "disconnected",
    timestamp: new Date().toISOString(),
  }
  res.json(health)
})

// Scan file endpoint (with rate limiting and API key check)
app.post(
  "/scan",
  scanLimiter,
  checkApiKey,
  upload.single("file"),
  async (req, res) => {
    const startTime = Date.now()
    const requestId = crypto.randomUUID()

    try {
      if (!req.file) {
        log("warn", "No file provided", { ip: req.ip, requestId })
        return res.status(400).json({ error: "No file provided" })
      }

      // Security: Sanitize filename
      const originalFilename = req.file.originalname || "unknown"
      const sanitizedFilename = sanitize(originalFilename)
      const fileSize = req.file.size

      log("info", "Scan request received", {
        requestId,
        ip: req.ip,
        filename: sanitizedFilename,
        size: fileSize,
      })

      // Security: Validate MIME type using magic numbers with fallback to provided mimetype when unknown
      const validation = await validateFileType(
        req.file.buffer,
        sanitizedFilename,
        req.file.mimetype,
      )
      if (!validation.valid) {
        log("warn", "File validation failed", {
          requestId,
          filename: sanitizedFilename,
          reason: validation.reason,
        })
        return res.status(400).json({
          error: "Invalid file type",
          details: validation.reason
        })
      }

      // Initialize ClamAV if needed
      const clam = await initClamAV()

      // Scan the file
      const { Readable } = require("stream")
      const stream = Readable.from(req.file.buffer)

      const { isInfected, viruses } = await clam.scanStream(stream)

      if (isInfected && viruses && viruses.length > 0) {
        const threat = viruses[0]

        // False positive patterns (conservative approach)
        const FALSE_POSITIVE_PATTERNS = [
          /Heuristics\.Broken\./i,
          /Heuristics\.Limits\./i,
        ]

        const isFalsePositive = FALSE_POSITIVE_PATTERNS.some((pattern) =>
          pattern.test(threat)
        )

        // Only allow false positives for verified safe media types
        if (isFalsePositive && validation.mimeType.startsWith("image/")) {
          log("info", "False positive ignored for image", {
            requestId,
            filename: sanitizedFilename,
            threat,
            mimeType: validation.mimeType,
          })
          return res.json({ safe: true, scanTime: Date.now() - startTime })
        }

        // Real malware detected
        log("error", "Malware detected", {
          requestId,
          filename: sanitizedFilename,
          threat,
          ip: req.ip,
        })

        return res.json({
          safe: false,
          threat: threat,
          scanTime: Date.now() - startTime,
        })
      }

      // File is clean
      log("info", "File passed scan", {
        requestId,
        filename: sanitizedFilename,
        scanTime: Date.now() - startTime,
      })

      res.json({
        safe: true,
        scanTime: Date.now() - startTime
      })

    } catch (error) {
      log("error", "Scan error", {
        requestId,
        error: error.message,
        code: error.code,
        ip: req.ip,
      })

      // Security: DO NOT bypass on errors
      // If ClamAV fails, reject the file
      res.status(500).json({
        error: "Scan failed",
        message: "Unable to complete security scan"
      })
    }
  }
)

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: "Not found" })
})

// Error handler
app.use((err, req, res, next) => {
  log("error", "Unhandled error", {
    error: err.message,
    stack: CONFIG.NODE_ENV === "development" ? err.stack : undefined,
  })

  // Don't expose internal errors in production
  const message = CONFIG.NODE_ENV === "production"
    ? "Internal server error"
    : err.message

  res.status(500).json({ error: message })
})

// Start server
app.listen(CONFIG.PORT, () => {
  log("info", "Malware scanner started", {
    port: CONFIG.PORT,
    nodeEnv: CONFIG.NODE_ENV,
    clamavHost: CONFIG.CLAMAV_HOST,
    clamavPort: CONFIG.CLAMAV_PORT,
  })

  // Initialize ClamAV on startup
  initClamAV().catch((error) => {
    log("error", "Failed to initialize ClamAV on startup", {
      error: error.message,
    })
    process.exit(1)
  })
})

// Graceful shutdown
process.on("SIGTERM", () => {
  log("info", "SIGTERM received, shutting down gracefully")
  process.exit(0)
})

process.on("SIGINT", () => {
  log("info", "SIGINT received, shutting down gracefully")
  process.exit(0)
})
